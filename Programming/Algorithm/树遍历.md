树的基本遍历

假设我们有这一样一个树
```python
from typing import Optional, List

class Node:
    value: int
    left: Optional['Node']
    right: Optional['Node']

    def __init__(self, value: int):
        self.value = value
        self.left = None
        self.right = None

node = Node(1)
node.left = Node(2)
node.right = Node(3)
node.left.left = Node(4)
node.left.right = Node(5)
node.left.left.left = Node(6)
node.left.left.right = Node(7)
node.left.right.left = Node(8)
node.left.right.right = Node(9)
node.right.left = Node(10)
node.right.right = Node(11)

```

## DFS 深度优先遍历
深度优先遍历，一般有三种
* 前序遍历: 访问顺序是根节点 -> 左子树 -> 右子树
* 中序遍历: 访问顺序是左子树 -> 根节点 -> 右子树
* 后序遍历:访问顺序是左子树 -> 右子树 -> 根节点

### 前序遍历
指的是先从做开始，计算到最底层，然后计算最底层节点，从做到右

```python

def depth_first_search(root: Optional[Node]):
    ans = []
    def dfs(node: Optional[Node]):
        if not node:
            return
        ans.append(node.value)
        dfs(node.left)
        dfs(node.right)

    dfs(root)
    return ans
    
ans = depth_first_search(node)
print(ans)
```


### 前序遍历二
上面的前序遍历的代码，我们也可以用一个更容易看懂，更简洁的方式（效率可能低一些）
```python
def first_traverse(node: Node):
    if not node:
        return []
    return  [ node.value ] + first_traverse(node.left)  + first_traverse(node.right)

res = first_traverse(node)
print(res)

```
### 中序遍历
从最左侧开始，然后中间值，再右侧
```python
def mid_traverse(node: Node):
    if not node:
        return []
    return mid_traverse(node.left) + [ node.value ] + mid_traverse(node.right)

```




## 广度优先遍历

```python

def breath_first_search(root: Node):
    result = []
    queue = [root]
    while queue:
        node = queue.pop(0)
        if not node:
            continue
        result.append(node.value)
        queue.append(node.left)
        queue.append(node.right)
    return result

ans = breath_first_search(node)
print(ans)

```

