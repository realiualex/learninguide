## 说明
不同语言的正则实现可能都不同，支持的功能可能会略微有差异。一般以 grep 命令为例，默认是BRE基础正则，如果加上 `-E` 参数则是扩展正则 ERE，但ERE不支持 lookahead和 lookbehind，也不支持 命名捕获组 (变量命名)，所以还是有一定局限性，如果想要在 grep 里用lookahead和 lookbehind，要用 PCRE(Perl兼容正则)
Perl 提供的 PCRE 功能是最完善的，也影响了后续其他语言，但其他语言更多的是和 PCRE 兼容，或者在安全性方面做了一些裁剪

## 单词边界匹配

如果想要匹配非某几个单词以外的其他单词， 比如有单词： xx one two three yy aax sdf等等，想匹配除了 one two three以外的所有单词

```regex
\b(?!one\b|two\b|three\b)\w+\b
```

解释:

* \b 表示单词的边界，确保我们匹配的是整个单词而不是部分单词
* (?!one\b|two\b|three\b) 这是一个否定前瞻断言(negative lookahead assertion)，表示我们不希望匹配 one 或者 two或者 three后面紧跟着单词边界的地方。其中 (?!) 表示否定前瞻断言的开始，one\b 表示匹配 one后面紧跟着单词边界。| 表示逻辑或，two\b表示two这个残次边界的位置
* \w+ 表示匹配一个或多个字母数字字符(单词字符)
* \b 表示再次匹配单词边界，以确保我们匹配完整的单词

## 正向前查找 lookbehind 和正向后查找 lookahead
lookahead 前瞻(看右边) 和 lookbehind 后顾(看左边)，必须放在括号里（go语言自带的正则不支持这个feature，要用第三方包）
* lookahead 的写法是 
	* `?=` 后面的字符要符合指定的规范
	* `?!` 后面的字符，不符合指定的规范
* lookbehind 的写法
	* `?<=` 前面的字符符合指定规范
	* `?<!` 前面的字符不符合规范

使用 ?<= 可以查找从 = 后面的那个字符（不包含那个字符），开始进行匹配。比如下面的示例：是从 ( 后面的字符开始匹配。?= 是一个正后向查找lookahead，它表示查找=后面的字符作为终止查找，但不包含这个字符。下面的示例是查找 ()包含的所有字符，但不包含这个()括号。


一个数据比如是这样
```
abc="wpkh([2817ce8f/84h/1h/0h]tpubDDa8NBj9P8Yid5VjPdvmxQPzXzd9R42bnHCKdMWJzqKd7E1ds6qdphGoYhyUvLJJGNHZQ8r2gmydpA2yJnq9Xi3Yab5t2rG35xYKSBWtDtA/1/*)#n7krh3fv"
```
使用正则
```
echo $abc | grep -Po '(?<=\().*(?=\))'
```

得到的结果是
```
[2817ce8f/84h/1h/0h]tpubDDa8NBj9P8Yid5VjPdvmxQPzXzd9R42bnHCKdMWJzqKd7E1ds6qdphGoYhyUvLJJGNHZQ8r2gmydpA2yJnq9Xi3Yab5t2rG35xYKSBWtDtA/1/*
```
